generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                           String                 @id @default(cuid()) @map("id")
  email                        String                 @unique @map("email")
  username                     String?                @unique @map("username")
  passwordHash                 String                 @map("password_hash")
  name                         String?                @map("name")
  status                       UserStatus             @default(pending) @map("status")
  createdAt                    DateTime               @default(now()) @map("created_at")
  updatedAt                    DateTime               @updatedAt @map("updated_at")
  createdBy                    String?                @map("created_by")
  updatedBy                    String?                @map("updated_by")
  createdByUser                User?                  @relation("UserCreatedBy", fields: [createdBy], references: [id])
  updatedByUser                User?                  @relation("UserUpdatedBy", fields: [updatedBy], references: [id])
  createdUsers                 User[]                 @relation("UserCreatedBy")
  updatedUsers                 User[]                 @relation("UserUpdatedBy")
  createdCredentials           Credential[]           @relation("CredentialCreatedBy")
  updatedCredentials           Credential[]           @relation("CredentialUpdatedBy")
  createdServers               Server[]               @relation("ServerCreatedBy")
  updatedServers               Server[]               @relation("ServerUpdatedBy")
  createdServices              Service[]              @relation("ServiceCreatedBy")
  updatedServices              Service[]              @relation("ServiceUpdatedBy")
  createdGroups                Group[]                @relation("GroupCreatedBy")
  updatedGroups                Group[]                @relation("GroupUpdatedBy")
  createdTags                  Tag[]                  @relation("TagCreatedBy")
  updatedTags                  Tag[]                  @relation("TagUpdatedBy")
  createdReleaseNotes          ReleaseNote[]          @relation("ReleaseNoteCreatedBy")
  updatedReleaseNotes          ReleaseNote[]          @relation("ReleaseNoteUpdatedBy")
  createdDomains               Domain[]               @relation("DomainCreatedBy")
  updatedDomains               Domain[]               @relation("DomainUpdatedBy")
  createdServiceDependencies   ServiceDependency[]    @relation("ServiceDependencyCreatedBy")
  updatedServiceDependencies   ServiceDependency[]    @relation("ServiceDependencyUpdatedBy")
  createdMeta                  Meta[]                 @relation("MetaCreatedBy")
  updatedMeta                  Meta[]                 @relation("MetaUpdatedBy")
  audits                       Audit[]                @relation("AuditUser")
  roles                        UserRole[]
  tags                         UserTag[]
  deleted                      Boolean                @default(false) @map("deleted")
  deletedAt                    DateTime?              @map("deleted_at")
  deletedBy                    String?                @map("deleted_by")
  deletedByUser                User?                  @relation("UserDeletedBy", fields: [deletedBy], references: [id])
  deletedCredentials           Credential[]           @relation("CredentialDeletedBy")
  deletedServers               Server[]               @relation("ServerDeletedBy")
  deletedServices              Service[]              @relation("ServiceDeletedBy")
  deletedGroups                Group[]                @relation("GroupDeletedBy")
  deletedTags                  Tag[]                  @relation("TagDeletedBy")
  deletedDomains               Domain[]               @relation("DomainDeletedBy")
  deletedUsers                 User[]                 @relation("UserDeletedBy")
  filterPresets                FilterPreset[]         @relation("FilterPresetUser")
  createdTasks                 Task[]                 @relation("TaskCreatedBy")
  assignedTasks                Task[]                 @relation("TaskAssignedTo")
  testingTasks                 Task[]                 @relation("TaskTester")
  completedTasks               Task[]                 @relation("TaskCompletedBy")
  updatedTasks                 Task[]                 @relation("TaskUpdatedBy")
  deletedTasks                 Task[]                 @relation("TaskDeletedBy")
  reopenedTasks                Task[]                 @relation("TaskReopenedBy")
  createdSprints               Sprint[]               @relation("SprintCreatedBy")
  updatedSprints               Sprint[]               @relation("SprintUpdatedBy")
  deletedSprints               Sprint[]               @relation("SprintDeletedBy")
  taskComments                 TaskComment[]          @relation("TaskCommentCreatedBy")
  taskCommentReactions         TaskCommentReaction[]  @relation("TaskCommentReactionUser")
  taskSprintHistoryMoves       TaskSprintHistory[]    @relation("TaskSprintHistoryMovedBy")
  createdTaskDependencies      TaskDependency[]       @relation("TaskDependencyCreatedBy")
  notifications                Notification[]         @relation("NotificationUser")
  attentionTasks               Task[]                 @relation("TaskAttentionTo")
  createdReleaseNoteShareLinks ReleaseNoteShareLink[] @relation("ReleaseNoteShareLinkCreatedBy")

  @@map("users")
}

model Role {
  id          String           @id @default(cuid()) @map("id")
  name        String           @unique @map("name")
  system      Boolean          @default(false) @map("system")
  deleted     Boolean          @default(false) @map("deleted")
  deletedAt   DateTime?        @map("deleted_at")
  users       UserRole[]
  permissions RolePermission[]

  @@map("roles")
}

model Permission {
  id          String           @id @default(cuid()) @map("id")
  name        String           @unique @map("name")
  resource    String           @map("resource")
  action      String           @map("action")
  description String?          @map("description")
  system      Boolean          @default(false) @map("system")
  deleted     Boolean          @default(false) @map("deleted")
  deletedAt   DateTime?        @map("deleted_at")
  roles       RolePermission[]

  @@unique([resource, action])
  @@map("permissions")
}

model UserRole {
  userId String @map("user_id")
  roleId String @map("role_id")
  user   User   @relation(fields: [userId], references: [id])
  role   Role   @relation(fields: [roleId], references: [id])

  @@id([userId, roleId])
  @@map("user_roles")
}

model RolePermission {
  roleId       String     @map("role_id")
  permissionId String     @map("permission_id")
  role         Role       @relation(fields: [roleId], references: [id])
  permission   Permission @relation(fields: [permissionId], references: [id])

  @@id([roleId, permissionId])
  @@map("role_permissions")
}

// Domain models
model Credential {
  id            Int                 @id @default(autoincrement()) @map("id")
  name          String              @map("name")
  type          String              @map("type")
  createdAt     DateTime            @default(now()) @map("created_at")
  updatedAt     DateTime            @updatedAt @map("updated_at")
  createdBy     String?             @map("created_by")
  updatedBy     String?             @map("updated_by")
  createdByUser User?               @relation("CredentialCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?               @relation("CredentialUpdatedBy", fields: [updatedBy], references: [id])
  deleted       Boolean             @default(false) @map("deleted")
  deletedAt     DateTime?           @map("deleted_at")
  deletedBy     String?             @map("deleted_by")
  deletedByUser User?               @relation("CredentialDeletedBy", fields: [deletedBy], references: [id])
  services      ServiceCredential[]
  servers       ServerCredential[]
  tags          CredentialTag[]

  @@index([deleted])
  @@map("credentials")
}

model ServerCredential {
  serverId     Int        @map("server_id")
  credentialId Int        @map("credential_id")
  server       Server     @relation(fields: [serverId], references: [id], onDelete: Cascade)
  credential   Credential @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  @@id([serverId, credentialId])
  @@map("server_credentials")
}

enum ServerType {
  os
  rds
  amplify
  lambda
  ec2
  ecs
  other
}

model Server {
  id               Int                @id @default(autoincrement()) @map("id")
  name             String             @map("name")
  type             ServerType         @default(os) @map("type")
  publicIp         String?            @map("public_ip")
  privateIp        String?            @map("private_ip")
  endpoint         String?            @map("endpoint")
  port             Int?               @map("port")
  sshPort          Int?               @map("ssh_port")
  username         String?            @map("username")
  password         String?            @map("password")
  documentationUrl String?            @map("documentation_url")
  documentation    String?            @map("documentation") @db.Text
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @updatedAt @map("updated_at")
  createdBy        String?            @map("created_by")
  updatedBy        String?            @map("updated_by")
  createdByUser    User?              @relation("ServerCreatedBy", fields: [createdBy], references: [id])
  updatedByUser    User?              @relation("ServerUpdatedBy", fields: [updatedBy], references: [id])
  deleted          Boolean            @default(false) @map("deleted")
  deletedAt        DateTime?          @map("deleted_at")
  deletedBy        String?            @map("deleted_by")
  deletedByUser    User?              @relation("ServerDeletedBy", fields: [deletedBy], references: [id])
  services         ServiceServer[]
  tags             ServerTag[]
  credentials      ServerCredential[]
  domains          ServerDomain[]

  @@index([deleted])
  @@map("servers")
}

model Service {
  id                Int                 @id @default(autoincrement()) @map("id")
  name              String              @map("name")
  port              Int                 @map("port")
  external          Boolean             @default(false) @map("external")
  sourceRepo        String?             @map("source_repo")
  appId             String?             @map("app_id")
  functionName      String?             @map("function_name")
  deploymentUrl     String?             @map("deployment_url")
  documentationUrl  String?             @map("documentation_url")
  documentation     String?             @map("documentation") @db.Text
  metadata          Json?               @map("metadata")
  createdAt         DateTime            @default(now()) @map("created_at")
  updatedAt         DateTime            @updatedAt @map("updated_at")
  createdBy         String?             @map("created_by")
  updatedBy         String?             @map("updated_by")
  createdByUser     User?               @relation("ServiceCreatedBy", fields: [createdBy], references: [id])
  updatedByUser     User?               @relation("ServiceUpdatedBy", fields: [updatedBy], references: [id])
  deleted           Boolean             @default(false) @map("deleted")
  deletedAt         DateTime?           @map("deleted_at")
  deletedBy         String?             @map("deleted_by")
  deletedByUser     User?               @relation("ServiceDeletedBy", fields: [deletedBy], references: [id])
  servers           ServiceServer[]
  tags              ServiceTag[]
  releaseNotes      ReleaseNote[]
  credentials       ServiceCredential[]
  domains           ServiceDomain[]
  dependencies      ServiceDependency[] @relation("ServiceDependencies")
  dependentServices ServiceDependency[] @relation("ServiceDependents")
  tasks             Task[]

  @@index([deleted])
  @@map("services")
}

enum GroupItemType {
  server
  service
  credential
  domain
  user
}

model Group {
  id            Int         @id @default(autoincrement()) @map("id")
  name          String      @unique @map("name")
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  createdBy     String?     @map("created_by")
  updatedBy     String?     @map("updated_by")
  createdByUser User?       @relation("GroupCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?       @relation("GroupUpdatedBy", fields: [updatedBy], references: [id])
  deleted       Boolean     @default(false) @map("deleted")
  deletedAt     DateTime?   @map("deleted_at")
  deletedBy     String?     @map("deleted_by")
  deletedByUser User?       @relation("GroupDeletedBy", fields: [deletedBy], references: [id])
  items         GroupItem[]

  @@index([deleted])
  @@map("groups")
}

model GroupItem {
  id       Int           @id @default(autoincrement()) @map("id")
  groupId  Int           @map("group_id")
  group    Group         @relation(fields: [groupId], references: [id])
  itemType GroupItemType @map("item_type")
  itemId   String        @map("item_id") // Changed to String to support both numeric IDs (as strings) and user IDs (CUIDs)

  @@map("group_items")
}

model Tag {
  id            Int             @id @default(autoincrement()) @map("id")
  name          String          @map("name")
  value         String?         @map("value")
  color         String?         @map("color")
  createdAt     DateTime        @default(now()) @map("created_at")
  updatedAt     DateTime        @updatedAt @map("updated_at")
  createdBy     String?         @map("created_by")
  updatedBy     String?         @map("updated_by")
  createdByUser User?           @relation("TagCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?           @relation("TagUpdatedBy", fields: [updatedBy], references: [id])
  deleted       Boolean         @default(false) @map("deleted")
  deletedAt     DateTime?       @map("deleted_at")
  deletedBy     String?         @map("deleted_by")
  deletedByUser User?           @relation("TagDeletedBy", fields: [deletedBy], references: [id])
  services      ServiceTag[]
  servers       ServerTag[]
  credentials   CredentialTag[]
  domains       DomainTag[]
  users         UserTag[]
  tasks         TaskTag[]

  @@unique([name, value])
  @@index([deleted])
  @@map("tags")
}

model ServiceTag {
  serviceId Int     @map("service_id")
  tagId     Int     @map("tag_id")
  service   Service @relation(fields: [serviceId], references: [id])
  tag       Tag     @relation(fields: [tagId], references: [id])

  @@id([serviceId, tagId])
  @@map("service_tags")
}

model ServerTag {
  serverId Int    @map("server_id")
  tagId    Int    @map("tag_id")
  server   Server @relation(fields: [serverId], references: [id])
  tag      Tag    @relation(fields: [tagId], references: [id])

  @@id([serverId, tagId])
  @@map("server_tags")
}

model CredentialTag {
  credentialId Int        @map("credential_id")
  tagId        Int        @map("tag_id")
  credential   Credential @relation(fields: [credentialId], references: [id], onDelete: Cascade)
  tag          Tag        @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([credentialId, tagId])
  @@map("credential_tags")
}

model DomainTag {
  domainId Int    @map("domain_id")
  tagId    Int    @map("tag_id")
  domain   Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)
  tag      Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([domainId, tagId])
  @@map("domain_tags")
}

model UserTag {
  userId String @map("user_id")
  tagId  Int    @map("tag_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([userId, tagId])
  @@map("user_tags")
}

enum ReleaseStatus {
  pending
  deployment_started
  deployed
}

enum UserStatus {
  pending
  approved
  blocked
  rejected
}

model ReleaseNote {
  id            Int               @id @default(autoincrement()) @map("id")
  serviceId     Int               @map("service_id")
  service       Service           @relation(fields: [serviceId], references: [id])
  note          String            @map("note")
  status        ReleaseStatus     @default(pending) @map("status")
  publishDate   DateTime          @default(now()) @map("publish_date")
  deployedAt    DateTime?         @map("deployed_at")
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")
  createdBy     String?           @map("created_by")
  updatedBy     String?           @map("updated_by")
  createdByUser User?             @relation("ReleaseNoteCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?             @relation("ReleaseNoteUpdatedBy", fields: [updatedBy], references: [id])
  tasks         ReleaseNoteTask[]
  notifications Notification[]

  @@map("release_notes")
}

model Domain {
  id            Int             @id @default(autoincrement()) @map("id")
  name          String          @unique @map("name")
  createdAt     DateTime        @default(now()) @map("created_at")
  updatedAt     DateTime        @updatedAt @map("updated_at")
  createdBy     String?         @map("created_by")
  updatedBy     String?         @map("updated_by")
  createdByUser User?           @relation("DomainCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?           @relation("DomainUpdatedBy", fields: [updatedBy], references: [id])
  deleted       Boolean         @default(false) @map("deleted")
  deletedAt     DateTime?       @map("deleted_at")
  deletedBy     String?         @map("deleted_by")
  deletedByUser User?           @relation("DomainDeletedBy", fields: [deletedBy], references: [id])
  servers       ServerDomain[]
  services      ServiceDomain[]
  tags          DomainTag[]

  @@index([deleted])
  @@map("domains")
}

model ServiceCredential {
  serviceId    Int        @map("service_id")
  credentialId Int        @map("credential_id")
  service      Service    @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  credential   Credential @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  @@id([serviceId, credentialId])
  @@map("service_credentials")
}

model ServerDomain {
  serverId Int    @map("server_id")
  domainId Int    @map("domain_id")
  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)
  domain   Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@id([serverId, domainId])
  @@map("server_domains")
}

model ServiceDomain {
  serviceId Int     @map("service_id")
  domainId  Int     @map("domain_id")
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  domain    Domain  @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@id([serviceId, domainId])
  @@map("service_domains")
}

model ServiceServer {
  serviceId Int     @map("service_id")
  serverId  Int     @map("server_id")
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  server    Server  @relation(fields: [serverId], references: [id], onDelete: Cascade)

  @@id([serviceId, serverId])
  @@map("service_servers")
}

model ServiceDependency {
  id        Int     @id @default(autoincrement()) @map("id")
  serviceId Int     @map("service_id")
  service   Service @relation("ServiceDependencies", fields: [serviceId], references: [id], onDelete: Cascade)

  // Internal dependency (references another service)
  dependencyServiceId Int?     @map("dependency_service_id")
  dependencyService   Service? @relation("ServiceDependents", fields: [dependencyServiceId], references: [id], onDelete: Cascade)

  // External dependency (third-party services like OpenAI, AWS, etc.)
  externalServiceName String? @map("external_service_name")
  externalServiceType String? @map("external_service_type")
  externalServiceUrl  String? @map("external_service_url")
  description         String? @map("description")

  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  createdBy     String?  @map("created_by")
  updatedBy     String?  @map("updated_by")
  createdByUser User?    @relation("ServiceDependencyCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?    @relation("ServiceDependencyUpdatedBy", fields: [updatedBy], references: [id])

  // Ensure either dependencyServiceId or externalServiceName is provided
  @@index([serviceId])
  @@index([dependencyServiceId])
  @@map("service_dependencies")
}

// Meta table for storing key-value pairs for any resource
enum MetaResourceType {
  credential
  server
  service
  user
  group
  tag
  domain
}

enum MetaValueType {
  string
  number
  boolean
  json
}

model Meta {
  id            Int              @id @default(autoincrement()) @map("id")
  resourceType  MetaResourceType @map("resource_type")
  resourceId    Int              @map("resource_id")
  key           String           @map("key")
  value         String           @map("value") // Encrypted value stored as string
  valueType     MetaValueType    @default(string) @map("value_type")
  createdAt     DateTime         @default(now()) @map("created_at")
  updatedAt     DateTime         @updatedAt @map("updated_at")
  createdBy     String?          @map("created_by")
  updatedBy     String?          @map("updated_by")
  createdByUser User?            @relation("MetaCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?            @relation("MetaUpdatedBy", fields: [updatedBy], references: [id])

  // Note: Polymorphic relations - resourceId refers to different tables based on resourceType
  // Foreign key constraints cannot be enforced at DB level for polymorphic relations
  // Relations are handled at application level

  @@unique([resourceType, resourceId, key])
  @@index([resourceType, resourceId])
  @@map("meta")
}

// Audit logging for critical resources
enum AuditResourceType {
  user
  server
  service
  credential
  tag
  domain
  group
  role
  permission
  task
  sprint
  task_comment
}

enum AuditAction {
  create
  update
  delete
  restore
}

model Audit {
  id           Int               @id @default(autoincrement()) @map("id")
  resourceType AuditResourceType @map("resource_type")
  resourceId   String            @map("resource_id") // String to support both Int and String IDs
  action       AuditAction       @map("action")
  userId       String?           @map("user_id")
  user         User?             @relation("AuditUser", fields: [userId], references: [id])
  changes      Json?             @map("changes") // Stores before/after values
  metadata     Json?             @map("metadata") // Additional context
  ipAddress    String?           @map("ip_address")
  userAgent    String?           @map("user_agent")
  createdAt    DateTime          @default(now()) @map("created_at")

  @@index([resourceType, resourceId])
  @@index([userId])
  @@index([createdAt])
  @@map("audits")
}

model FilterPreset {
  id        Int      @id @default(autoincrement()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation("FilterPresetUser", fields: [userId], references: [id], onDelete: Cascade)
  pageId    String   @map("page_id") // 'release-notes', 'services', 'servers', 'credentials', 'domains'
  name      String   @map("name")
  filters   Json?    @map("filters") // Store the filter object as JSON (nullable)
  orderBy   Json?    @map("order_by") // Store orderBy array as JSON (nullable)
  groupBy   Json?    @map("group_by") // Store groupBy array as JSON (nullable)
  isShared  Boolean  @default(false) @map("is_shared") // Optional: allow sharing with other users
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId, pageId])
  @@index([userId])
  @@index([pageId, isShared])
  @@map("filter_presets")
}

// ============================================================================
// TASK MANAGEMENT SYSTEM
// ============================================================================

// Task Status Enum
enum TaskStatus {
  pending // Initial state when created
  in_progress // Developer has started work
  in_review // Code review phase
  proceed // Attention user resolved review/block
  testing // Assigned to tester
  not_fixed // Tester marked as not fixed/persisting
  completed // Task completed and verified
  paused // Work temporarily stopped
  blocked // Blocked by dependencies
  cancelled // Task cancelled
  reopened // Task reopened after completion (bug came back)
}

// Task Priority Enum
enum TaskPriority {
  low
  medium
  high
  critical
}

// Task Type Enum
enum TaskType {
  bug
  feature
  todo
  epic
  improvement
}

// Sprint Status Enum
enum SprintStatus {
  planned
  active
  completed
  cancelled
}

// Sprint Model
model Sprint {
  id            Int                 @id @default(autoincrement()) @map("id")
  name          String              @map("name")
  description   String?             @map("description") @db.Text
  startDate     DateTime            @map("start_date")
  endDate       DateTime            @map("end_date")
  status        SprintStatus        @default(planned) @map("status")
  createdAt     DateTime            @default(now()) @map("created_at")
  updatedAt     DateTime            @updatedAt @map("updated_at")
  createdBy     String?             @map("created_by")
  updatedBy     String?             @map("updated_by")
  createdByUser User?               @relation("SprintCreatedBy", fields: [createdBy], references: [id])
  updatedByUser User?               @relation("SprintUpdatedBy", fields: [updatedBy], references: [id])
  deleted       Boolean             @default(false) @map("deleted")
  deletedAt     DateTime?           @map("deleted_at")
  deletedBy     String?             @map("deleted_by")
  deletedByUser User?               @relation("SprintDeletedBy", fields: [deletedBy], references: [id])
  tasks         Task[]
  taskHistory   TaskSprintHistory[]

  @@index([deleted])
  @@index([status])
  @@map("sprints")
}

// Task Model
model Task {
  id          Int          @id @default(autoincrement()) @map("id")
  title       String       @map("title")
  description String?      @map("description") @db.Text
  type        TaskType     @default(todo) @map("type")
  status      TaskStatus   @default(pending) @map("status")
  priority    TaskPriority @default(medium) @map("priority")

  // Sprint relationship (nullable - tasks can be in backlog)
  sprintId Int?    @map("sprint_id")
  sprint   Sprint? @relation(fields: [sprintId], references: [id])

  // Assignment workflow
  createdBy     String? @map("created_by")
  createdByUser User?   @relation("TaskCreatedBy", fields: [createdBy], references: [id])

  assignedTo     String?   @map("assigned_to")
  assignedToUser User?     @relation("TaskAssignedTo", fields: [assignedTo], references: [id])
  assignedAt     DateTime? @map("assigned_at")

  testerId         String?   @map("tester_id")
  tester           User?     @relation("TaskTester", fields: [testerId], references: [id])
  testerAssignedAt DateTime? @map("tester_assigned_at")

  // Attention/notification for review or block
  attentionToId   String? @map("attention_to_id")
  attentionToUser User?   @relation("TaskAttentionTo", fields: [attentionToId], references: [id])

  // Testing skip tracking
  testingSkipped    Boolean @default(false) @map("testing_skipped")
  testingSkipReason String? @map("testing_skip_reason") @db.Text

  completedBy     String?   @map("completed_by")
  completedByUser User?     @relation("TaskCompletedBy", fields: [completedBy], references: [id])
  completedAt     DateTime? @map("completed_at")

  // Reopen tracking
  reopenCount        Int       @default(0) @map("reopen_count")
  lastReopenedAt     DateTime? @map("last_reopened_at")
  lastReopenedBy     String?   @map("last_reopened_by")
  lastReopenedByUser User?     @relation("TaskReopenedBy", fields: [lastReopenedBy], references: [id])

  // Metadata
  estimatedHours Float?    @map("estimated_hours")
  actualHours    Float?    @map("actual_hours")
  dueDate        DateTime? @map("due_date")

  // Service relationship (optional)
  serviceId Int?     @map("service_id")
  service   Service? @relation(fields: [serviceId], references: [id])

  // Timestamps
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  updatedBy     String?  @map("updated_by")
  updatedByUser User?    @relation("TaskUpdatedBy", fields: [updatedBy], references: [id])

  // Soft delete
  deleted       Boolean   @default(false) @map("deleted")
  deletedAt     DateTime? @map("deleted_at")
  deletedBy     String?   @map("deleted_by")
  deletedByUser User?     @relation("TaskDeletedBy", fields: [deletedBy], references: [id])

  // Relations
  comments         TaskComment[]
  tags             TaskTag[]
  sprintHistory    TaskSprintHistory[]
  dependencies     TaskDependency[]    @relation("TaskDependencies")
  blockedBy        TaskDependency[]    @relation("BlockedByTasks")
  parentTaskId     Int?                @map("parent_task_id")
  parentTask       Task?               @relation("TaskSubtasks", fields: [parentTaskId], references: [id])
  subtasks         Task[]              @relation("TaskSubtasks")
  releaseNoteTasks ReleaseNoteTask[]
  notifications    Notification[]

  @@index([status])
  @@index([assignedTo])
  @@index([testerId])
  @@index([sprintId])
  @@index([deleted])
  @@index([createdBy])
  @@index([parentTaskId])
  @@index([attentionToId])
  @@map("tasks")
}

// Task Comments with Threading
model TaskComment {
  id     Int  @id @default(autoincrement()) @map("id")
  taskId Int  @map("task_id")
  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Threading support
  parentId Int?          @map("parent_id")
  parent   TaskComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  TaskComment[] @relation("CommentReplies")

  // Content
  content String @map("content") @db.Text

  // Author
  createdBy     String @map("created_by")
  createdByUser User   @relation("TaskCommentCreatedBy", fields: [createdBy], references: [id])

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Editing
  isEdited Boolean @default(false) @map("is_edited")

  // Soft delete
  deleted   Boolean   @default(false) @map("deleted")
  deletedAt DateTime? @map("deleted_at")

  // Reactions
  reactions TaskCommentReaction[]

  // Notifications
  notifications Notification[]

  @@index([taskId])
  @@index([parentId])
  @@index([createdBy])
  @@index([deleted])
  @@map("task_comments")
}

// Comment Reactions
model TaskCommentReaction {
  id        Int         @id @default(autoincrement()) @map("id")
  commentId Int         @map("comment_id")
  comment   TaskComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId    String      @map("user_id")
  user      User        @relation("TaskCommentReactionUser", fields: [userId], references: [id])
  emoji     String      @map("emoji") // üëç, ‚ù§Ô∏è, üéâ, etc.
  createdAt DateTime    @default(now()) @map("created_at")

  @@unique([commentId, userId, emoji])
  @@index([commentId])
  @@map("task_comment_reactions")
}

// Task Tags (many-to-many with existing Tag model)
model TaskTag {
  taskId Int  @map("task_id")
  tagId  Int  @map("tag_id")
  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  tag    Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([taskId, tagId])
  @@map("task_tags")
}

// Notifications
model Notification {
  id     Int    @id @default(autoincrement()) @map("id")
  userId String @map("user_id")
  user   User   @relation("NotificationUser", fields: [userId], references: [id], onDelete: Cascade)

  // Notification type and context
  type          String       @map("type") // 'task_comment', 'task_assigned', etc.
  taskId        Int?         @map("task_id")
  task          Task?        @relation(fields: [taskId], references: [id], onDelete: Cascade)
  commentId     Int?         @map("comment_id")
  comment       TaskComment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  releaseNoteId Int?         @map("release_note_id")
  releaseNote   ReleaseNote? @relation(fields: [releaseNoteId], references: [id], onDelete: Cascade)

  // Content
  title   String @map("title")
  message String @map("message") @db.Text

  // Status
  read   Boolean   @default(false) @map("read")
  readAt DateTime? @map("read_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([userId, read])
  @@index([taskId])
  @@map("notifications")
}

// Task Sprint History - Track all sprint movements
model TaskSprintHistory {
  id          Int      @id @default(autoincrement()) @map("id")
  taskId      Int      @map("task_id")
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  sprintId    Int?     @map("sprint_id") // Nullable for backlog
  sprint      Sprint?  @relation(fields: [sprintId], references: [id])
  movedAt     DateTime @default(now()) @map("moved_at")
  movedBy     String?  @map("moved_by")
  movedByUser User?    @relation("TaskSprintHistoryMovedBy", fields: [movedBy], references: [id])
  reason      String?  @map("reason") @db.Text // e.g., "Task reopened", "Moved to next sprint"

  @@index([taskId])
  @@index([sprintId])
  @@map("task_sprint_history")
}

// Task Dependencies - Track blocking relationships
model TaskDependency {
  id              Int      @id @default(autoincrement()) @map("id")
  taskId          Int      @map("task_id")
  task            Task     @relation("TaskDependencies", fields: [taskId], references: [id], onDelete: Cascade)
  blockedByTaskId Int      @map("blocked_by_task_id")
  blockedByTask   Task     @relation("BlockedByTasks", fields: [blockedByTaskId], references: [id], onDelete: Cascade)
  createdAt       DateTime @default(now()) @map("created_at")
  createdBy       String?  @map("created_by")
  createdByUser   User?    @relation("TaskDependencyCreatedBy", fields: [createdBy], references: [id])

  @@unique([taskId, blockedByTaskId])
  @@index([taskId])
  @@index([blockedByTaskId])
  @@map("task_dependencies")
}

// Release Note to Task Mapping
model ReleaseNoteTask {
  id            Int         @id @default(autoincrement()) @map("id")
  releaseNoteId Int         @map("release_note_id")
  releaseNote   ReleaseNote @relation(fields: [releaseNoteId], references: [id], onDelete: Cascade)
  taskId        Int         @map("task_id")
  task          Task        @relation(fields: [taskId], references: [id], onDelete: Cascade)
  createdAt     DateTime    @default(now()) @map("created_at")

  @@unique([releaseNoteId, taskId])
  @@index([releaseNoteId])
  @@index([taskId])
  @@map("release_note_tasks")
}

// Public Share Links for Release Notes
model ReleaseNoteShareLink {
  id            String    @id @default(uuid()) @map("id")
  shareToken    String    @unique @map("share_token") // Unique token for the share link
  filters       Json?     @map("filters") // Store filter object as JSON
  expiresAt     DateTime? @map("expires_at") // Null means never expires
  createdAt     DateTime  @default(now()) @map("created_at")
  createdBy     String?   @map("created_by")
  createdByUser User?     @relation("ReleaseNoteShareLinkCreatedBy", fields: [createdBy], references: [id], onDelete: SetNull)
  viewCount     Int       @default(0) @map("view_count")
  lastViewedAt  DateTime? @map("last_viewed_at")

  @@index([shareToken])
  @@index([createdBy])
  @@index([expiresAt])
  @@map("release_note_share_links")
}
